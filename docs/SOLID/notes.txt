*** Single responsibility principle ***
A class should only be responsible for one thing. To make sure this is true,
check to see how many things can change within a class. For example, a class
that is responsible for comiling and printing data could change in at least two
areas. If the format of the data is to change, or if the content of the data
changes. In the mentioned example, the class should be divided into a compile
class and a print class, separately.

*** Open/closed principle ***
Entities such as classes, modules, functions etc. should only be open for
extension and closed for modification.
Open Module: Available for extension and possible to add fields to the data
structures it contains, or new elements to the set of functions it performs.
Closed Module: Available for use by other modules. The module can be extended
via inheritance and features can be added to it without changing its parent
class's source code.
NOTE: There is mention of abstract base classes being used as an abstraced
      interface that cannot be touched once it is created. All new features
	  must implement that interface so that the existing interface is closed
	  to modifications and the new implementation can use that base interface.

*** Liskov substitution principle ***
A sublcass must provide support for all behavior supported by the super-class;
subclasses must implement any mutator methods defined in a base class. In the
case of having a Rectangle class where there is a width and a height that do
not have to be equal, you could not make a Square be a sub-class of the
rectangle class because the setWidth/Heigth methods would have to apply the
same value to the width/height respectively.

So even though a Square is a special case of a Rectangle, what the Liskov
Substitution Principle says is that, since the observable behavior of a Square
is wildly different from that of a Rectangle, a Square shouldn't be treated as
a subtype for a Rectangle.

A Simple Example of a Violation of LSP:

void DrawShape(const Shape& s)
{
	if (typeid(s) == typeid(Square))
		DrawSquare(static_cast<Square&>(s));
	else if (typeid(s) == typeid(Cirlce))
		DrawCircle(static_cast<Circle&>(s);
}

DrawShape function takes a reference to Shape class and checks to see what kind
of Shape it is and draws it. I needs to know about every possible derivative of
Shape and when a new derivative is created, ie typeid(Triangle), then DrawShape
will need to be modified to accomodate the new derivative.

In most cases, when inheriting a new obj. from an old obj. the new obj. follows
the IS-A relationship. The Rectangle->Square relationship is hard to catch
until the program is being written.

class Rectangle
{
public:
	void SetWidth(double w) { itsWidth = w; }
	void SetHeight(double h) { itsHeight = w; }
	double GetHeight() const { return itsHeight; }
	double GetWidth() const { return itsWidth; }

private:
	double itsWidth;
	dobule itsHeight;
}

Clues that this is going to go wrong:
	Square does not need both itsHeight and itsWidth member variables, but it
	will inherit them anyway. In the case of writing a CAD/CAE program where
	thousands of squares could be drawn, the wastefulness could be significant.
	Besides wasting memory, the SetWidth and SetHeight functions are wrong for
	a Square since its width and height are identical. Problem could be solved
	by overriding the SetWidth and SetHeight methods.

void Square::SetWidth(double w)
{
	Rectangle::SetWidth(w);
	Rectangle::SetHeight(w);
}

void Square::SetHeight(double h)
{
	Rectangle::SetHeight(h);
	Rectangle::SetWidth(h);
}

Above example fixes the issue.

Square s;
s.SetWidth(1); // sets width and height to 1
s.SetHeight(2); // sets wifth and height to 2

Consider this function:

void f(Rectangle& r)
{
	r.SetWidth(32); // calls Rectangle::SetWidth;
}

Issue: If a reference to Square obj. is passed into the 'f' function then it
violates LSP because the height won't be changed. The 'f' function does not
work for derivatives of its arguments. The reason is that SetWidth and
SetHeight were not declared 'virtual' in Rectangle.

Virtual functions:
	public abstract class Shape { // Java
		public abstract void draw();
	}

	In Java these are used via abstract class types. In C++ you get the same
	effect by using a pure virtual function. There is a little difference in
	C++ between 'virtual function/method' and PURE virtual functions/methods.
	The virtual function can be overriden and the pure function must be
	implemented by a derived class at runtime. MUST.

	So, in the example above, it works as a C++ pure virtual function, in that
	all classes derived from Shape, ie Square, Circle etc, will need to have
	its own draw() method so that the program can later do things like use the
	draw() method in a loop through any Shape derivative:

		for (Shape shape : shapeList) {
			shape.draw();
		}

	Same method can be used on all Shape derivatives without breaking anything.













	
